== Konzepte ==

==== Fahrplan ====

\tableofcontents[currentsection]

=== Grundbegriffe ===

==== Grundbegriffe ====

* '''Working Tree''': ein Verzeichnis, dessen Zustände in einem ''repository'' archiviert sind
* '''Repository''': ein Archiv der Zustände von einem ''working tree''
* '''Index''': die Verbindung zwischen ''working tree'' und ''repository''

<[figure][ht]
	<<<figs/state-diagram.pdf, scale=0.5>>>
[figure]>

* '''Commit''': ein spezifischer Zustand des ''working tree'' der im ''repository'' gespeichert ist

=== Objekt Modell === 

==== Objekt Modell ====

* '''Blob''': enthält im Allgemeinen den Inhalt einer Datei
* '''Tree''': eine Ansammlung von ''tree'' und ''blob'' Objekten, meist der Inhalt von einem Verzeichnis
* '''Commit''': besteht aus einem ''tree'' mit zusätzlichen Informationen, unter anderem: ''author'', ''parents'' und ''commit message''

<[figure][ht]
	<<<figs/objects.pdf, scale=0.6>>>
[figure]>

==== SHA-1 IDs ====

* ''objects'' werden mit '''SHA-1 IDs''' identifiziert
* Dies ist der '''object name'''
* ''SHA-1'' ist eine Hash-Funktion die eine beliebige Bit-Sequenz in eine Hexadezimal-Sequenz der Länge 40 übersetzt
* Wird aus dem Inhalt berechnet und ist somit fast einzigartig

<[figure][htp]
	<<<figs/sha.pdf, scale=0.7>>>
[figure]>

==== Zusammenfassung ====

Ein Git ''repository'' enthält ''commits'', diese wiederum bestehen aus ''trees'' und ''blobs''.

<[figure][ht]
	<<<figs/structure.pdf, scale=0.7>>>
[figure]>

[frame]>

==== ''commits'' Benennen ====

<[columns]
[[[3cm]]]

<[figure][ht]
	<<<figs/History.pdf, scale=0.7>>>
[figure]>

[[[9cm]]]

Für Git Kommandos müssen wir ''commits'' benennen

\hspace{1cm}

* Meist reicht ein '''partial SHA''': die ersten 4-7 Zeichen vom ''SHA-1 ID''
* \textbf{\texttt{HEAD}} : Zeiger auf den aktuellen ''commit''
* Relative Angaben mit \^{} und $\sim$
[columns]>

=== Inhalt von .git ===

\begin{frame}[fragile]
\frametitle{Inhalt von .git}

* Git speichert alles in dem Verzeichnis {\tt.git/} im Wurzelverzeichnis des ''working tree''.
* auch bekannt als \textbf{git directory}


hier ein Ausschnitt:

\begin{verbatim}

        .git/
        |-- HEAD            # Der HEAD
        |-- branches
        |-- config
        |-- index           # Der index
        |-- info
        |-- logs
        |-- objects         # Die objects
        `-- refs

\end{verbatim}

\end{frame}

== Arbeitsablauf ==

==== Fahrplan ====

\tableofcontents[currentsection]

=== Start ===

==== Ein ''repository'' bekommen ====

<[block]{Leeres ''repository'' aufsetzen}
    @git init@
[block]>

<[block]{Existierendes kopieren}
    @git clone@
[block]>

<[block]{Beispiel}
@git clone git://git.goodpoint.de/git-talk-val.git@
[block]>

==== Wichtig: Setzen von Namen und Email ====

<[block]{Setzen des Namen}
@git config user.name "Valentin Haenel"@
[block]>

<[block]{Setzen der Email}
\texttt{git config user.email valentin@cs.tu-berlin.de}
[block]>

* Sonst wird @username@ und @host@ von dem aktuellen Rechner verwendet

* Mit der Option @-{-}global@ werden diese der @$\sim$/.gitconfig@ hinzugefügt


==== FAIL! ====

Wird das Setzen von Name und Email vergessen:

\hspace{1cm}

<[figure][ht]
	<<<canvas.png, scale=0.23>>>
[figure]>

\href{http://github.com/esc/molif/graphs/impact}{Impact Graph von @molif@}: 
Jeder Farbe steht für einen ''committer'', aber bei dem Projekt gab es nur 2 Entwickler. :-(


==== Transport Kommandos ====

<[figure][ht]
	<<<figs/transport-commands.pdf, scale=0.6>>>
	\caption{Zusammenhang von @git add@, @git commit@ und @git checkout@}
[figure]>


=== Commits Machen  ===

==== Vom ''working tree'' in den ''index'' ====

Der '''index''' (auch ''staging area'' oder ''cache'' genannt) bietet die Möglichkeit einen ''commit'' schrittweise zusammenzusetzen. 

<[block]{Quellcode dem ''index'' hinzufügen}
    @git add@
[block]>

<[block]{Interaktiv einzelne Veränderungen hinzufügen}
@git add -p@
[block]>

<[block]{Sehen, welche Dateien sich im ''index'' befinden}
    @git status@
[block]>

==== Vom ''index'' in das ''repository'' ====

<[block]{Alles im ''index'' als ''commit'' ins ''repository''}
    @git commit@
[block]>

<[block]{''commit message'' angeben}
    @git commit -m "MESSAGE"@
[block]>

<[block]{''index'' umgehen, und direkt vom ''working tree'' ins ''repository''}
    @git commit -a@
[block]>

<[block]{''working tree'' in einen früheren Zustand zurückversetzen}
    @git checkout@
[block]>

=== Commit Geschichte ===

==== Die ''commit'' Geschichte einsehen ====

<[block]{Alle ''commits'' anzeigen}
@git log@
[block]>

<[block]{Optionen}
\begin{tabular}{ l l }
{\tt git log -N}                            & die letzten @N@ anzeigen\\
{\tt git log COMMIT}                        & bis zu @COMMIT@ anzeigen \\
{\tt git log -{-}since="23 hours"}            & alle seit ... \\
{\tt git log -{-}before="42 days"}            & alle vor ... \\
{\tt git log -{-}pretty=oneline}              & ein ''commit'' pro Zeile \\
{\tt git log A..B}                          & alle zwischen {\tt A} und {\tt B}
\end{tabular}
[block]>

=== Unterschiede Anzeigen ===

==== Unterschiede ====

<[block]{Unterschiede zwischen ''working tree'' ohne ''index'' und @HEAD@}
@git diff@
[block]>

<[block]{Unterschiede zwischen ''index'' und ''repository'' (Inhalt des ''index'')}
@git diff -{-}cached@
[block]>

<[block]{Unterschiede zwischen ''working tree'' mit ''index'' und @HEAD@}
@git diff HEAD@
[block]>

<[block]{Unterschiede zwischen zwei ''commits''}
@git diff A B@
[block]>

<[block]{Unterschiede zwischen den letzten zwei}
@git diff HEAD\^{} HEAD@
[block]>

== Fortgeschrittener Arbeitsablauf ==

==== Fahrplan ====

\tableofcontents[currentsection]

=== Branches ===

==== Branches ====

* Bisher: lineare ''commit''-Geschichte
* Problem: parallele Entwicklung
* Lösung: ''Branches''

* Neue Funktionalität 
* 'Herumexperimentieren'
* Bugs Reparieren

==== Branch Diagram ==== 

* '''Branch''': ein Zeiger auf einem  ''commit''
* Ein ''commit'' hat Vorfahren (evtl. mehrere)
* Der gemeinsame Vorfahre heisst '''base commit'''

<[figure][ht]
    <<<figs/branch-basic.pdf, scale=0.6>>>
[figure]>

* '''Master''': meist der Haupt-''branch''

==== Branch Kommandos ====

<[block]{Anzeigen der ''branches''}
@git branch@
[block]>

<[block]{''branch'' erstellen und hineinwechseln}
@git checkout -b NAME COMMIT@
[block]>

<[block]{In einen ''branch'' wechseln}
@git checkout NAME@
[block]>

<[block]{''branch'' löschen}
@git branch -d NAME@
[block]>

=== Merging ===

==== Verschiedene Merge Strategien ====

Das Zusammenführen von Veränderungen ('''merge''') aus zwei (oder mehr) ''branches'' kann auf vielerlei Arten passieren:

* '''Fast Forward''': den @HEAD@ vorspulen 
* '''Straight Merging''':  aus @HEAD@s von ''branches'' einen neuen ''commit'' machen
* '''Rebaseing''': den ''base commit'' ändern

==== ''fast forward'' ====

<[block]{Wenn der @HEAD@ der ''base commit'' ist}
@git merge@
[block]>

<[block]{Vorher}
<[figure][ht]
    \includegraphics[scale=0.35]{figs/fast-forward-before.pdf}
[figure]>
[block]>

\pause

<[block]{Nachher}
<[figure][ht]
    \includegraphics[scale=0.35]{figs/fast-forward-after.pdf}
[figure]>
[block]>

==== ''straight merge '' ====

<[block]{Wenn der @HEAD@ nicht der ''base commit'' ist}
@git merge@
[block]>

<[block]{Vorher}
<[figure][ht]
    \includegraphics[scale=0.32]{figs/merge-before.pdf}
[figure]>
[block]>

\pause

<[block]{Nachher}
<[figure][ht]
    \includegraphics[scale=0.32]{figs/merge-after.pdf}
[figure]>
[block]>

==== ''rebaseing'' ====

<[block]{Ändern vom ''base commit''}
@git rebase@
[block]>

<[block]{Vorher}
<[figure][ht]
    \includegraphics[scale=0.32]{figs/merge-before.pdf}
[figure]>
[block]>

\pause

<[block]{Nachher}
<[figure][ht]
    \includegraphics[scale=0.32]{figs/rebase-after.pdf}
[figure]>
[block]>

=== Tags ===

==== Tags ====

Da die ''SHA-1 IDs'' unhandlich und semantikarm sind, bietet Git eine
Möglichkeit, um ''commits'' mit Namen, so genanten ''tags'', zu versehen, z.B.
um eine Version zu kennzeichnen.

<[block]{Anzeigen aller tags}
@git tag@
[block]>

<[block]{Den @HEAD@ mit einem ''tag'' versehn}
@git tag NAME@
[block]>

<[block]{''tag'' löschen}
@git tag -d NAME@
[block]>

=== Zurücksetzen ===

==== Veränderungen Rückgängig machen die noch nicht im ''repository'' sind ====

<[block]{Veränderung aus dem ''index'' herausnehmen (''unstage'')}
@git reset HEAD@
[block]>

<[block]{Einzelne Datei zurücksetzen}
@git checkout FILE@
[block]>

<[block]{Gesamten ''working tree'' zurücksetzen}
@git reset -{-}hard HEAD@
[block]>

\textcolor{red}{\textbf{VORSICHT!} Veränderungen am ''working tree'' die zurückgesetzt werden sind unwiderruflich gelöscht}

==== Veränderungen Rückgängig machen die bereites im ''repository'' sind ====

<[block]{Rückgängig machen von ''commits''}
@git reset COMMIT@
* ohne Option: in den ''working tree''
* @-{-}soft@: in den ''index''
* @-{-}hard@: Löschen (\textcolor{red}{\textbf{VORSICHT!}})
[block]>

<[block]{Veränderungen von einem ''commit'' in einem neuen rückgängig machen}
@git revert@
[block]>

<[block]{Reihenfolge ändern, sowie ''commits'' trennen oder zusammenfügen}
@git rebase -i@
[block]>

=== Remote Repositories ===

==== ''remote repositories'' ====

* '''Remote Repositories''': Alle entfernten ''repositories''
* Jeder Entwickler hat ein lokales ''repository''
* Um mit anderen zu Kollaboration müssen die Veränderungen zwischen diesen synchronisiert werden
* Oft wird hierfür ein spezielles ''repository'' auf einem Server eingerichtet das keinen ''working tree'' hat

==== Transport Kommandos mit Remote ====

<[figure][ht]
	<<<figs/transport-commands-remote.pdf, scale=0.6>>>
[figure]>

==== Was passiert bei @git clone@ ====

<[block]{Beispiel}
@git clone git://git.goodpoint.de/git-talk-val.git@
[block]>

* Es entstehen zwei ''branches''
** @master@: lokale Arbeitskopie und '''remote tracking branch'''
** @origin/master@: lokale Kopie des '''remote branch'''

* @origin@: der Ursprung von unserm Klon

<[block]{Anzeigen aller ''branches''}
@git branch -a@
[block]>

==== Veränderungen hin-und-her schieben ====

<[block]{Veränderungen herunterladen}
@git fetch@
[block]>

<[block]{Herunterladen und @merge@}
@git pull@
[block]>

<[block]{Herunterladen und @rebase@}
@git pull -{-}rebase@
[block]>

<[block]{Veränderungen hochladen}
@git push@
[block]>

== Schluss ==

==== Was ich euch nicht erzählt habe ====

* Das Lösen von Konflikten bei @merge@ und @rebase@
* ''remote branches'' erstellen und löschen
* Dateien ignorieren mit @.gitignore@
* Git in Eclipse mit egit oder gitclipse
* Patches formatieren und per Email versenden
* Was der @reflog@ ist, und warum er ALLES speichert
* Wie man @git stash@ verwendet
* Git aliase erstellen

==== Literatur-Empfehlungen ====

* Pragmatic Version Control Using Git, by Travis Swicegood (200 pages, Dec 2008, ISBN: 9781934356159 )
* Sehr gute Einführung, exzellente Beispiele die auch online verfügbar sind

* \href{http://www.newartisans.com/2008/04/git-from-the-bottom-up.html}{git-from-the-bottom-up}
* Sehr gute Beschreibung der Details und trotzdem relativ kurz

* \href{http://book.git-scm.com/}{git community book}
* Hervorragende Beschreibung von ''objects'' und Implementationsdetails, Webseite mit Videos

==== Dank ====

Dank gilt den Entwicklern von:
* wiki2beamer
* \LaTeX beamer
* impressive
* dia
* pdflatex
* gnu make
* vim

Dank gilt folgenden Personen fürs Korrekturlesen und patches
* Dan Levin
* Sebastian Pipping
* Robert Buchholz 

