== Konzepte ==

==== Fahrplan ====

\tableofcontents[currentsection]


=== Grundbegriffe ===

==== Grundbegriffe ====

* '''Repository''': ein Archiv der Zustände von einem ''working tree''
* '''Working Tree''':ein Verzeichnis, dessen Zustände in einem ''repository'' archiviert sind
* '''Index''': die Verbindung zwischen ''working tree'' und ''repository''

<[figure][ht]
	<<<figs/state-diagram.pdf, scale=0.5>>>
[figure]>

* '''Commit''': ein spezifischer Zustand des ''working tree'' der im ''repository'' gespeichert ist

=== Objekt Model === 

==== Objekt Model ====

* '''Blob''': enthält im allgemeinen den Inhalt einer Datei
* '''Tree''': eine Ansammlung von ''tree'' und ''blob'' Objekten, meist der Inhalt von einem Verzeichnis
* '''Commit''': besteht aus einem ''tree'' mit zusätzlichen Informationen, unter anderem: ''author'', ''parents'' und ''commit message''

<[figure][ht]
	<<<figs/objects.pdf, scale=0.6>>>
[figure]>

==== SHA-1 IDs ====

* ''objects'' werden mit '''SHA-1 IDs''' identifiziert, auch bekannt als ''object name''
* ''SHA-1'' ist eine Hash-Funktion die eine beliebige Bit-Sequenz in eine Hexadezimal-Sequenz der Länge 40 übersetzt
* Wird aus dem Inhalt berechnet und ist somit fast Einzigartig
* Erlaubt es schnell ''objects'' miteinander zu vergleichen

<[figure][htp]
	<<<figs/sha.pdf, scale=0.7>>>
[figure]>


==== Zusammenfassung ====

Ein Git ''repository'' enthält ''commits'', diese wiederum bestehen aus ''trees'' und ''blobs''.

<[figure][ht]
	<<<figs/structure.pdf, scale=0.7>>>
[figure]>


== Arbeitsablauf ==

==== Fahrplan ====

\tableofcontents[currentsection]

=== Start ===

==== Ein ''repository'' bekommen ====

<[block]{leeres ''repository'' aufsetzen}
    @git init@
[block]>

<[block]{existierendes kopieren}
    @git clone@
[block]>

<[block]{Beispiel}
@git clone git://git.debian.org/git/pkg-exppsy/pymvpa.git@
[block]>


==== Wichtig: Setzen von Namen und Email ====

<[block]{setzen des Namen}
@git config user.name "Valentin Haenel"@
[block]>

<[block]{setzen der Email}
\texttt{git config user.email valentin@cs.tu-berlin.de}
[block]>

* Mit der option @-{-}global@ werden diese der @~/.gitconfig@ hinzugefügt
* Bei vergessen wird @username@ und @host@ von dem aktuellen Rechner verwendet

\hspace{0.5cm}

<[figure][ht]
	<<<canvas.png, scale=0.21>>>
    \caption{ \href{http://github.com/esc/molif/graphs/impact}{Impact Graph von @molif@}: 
    Jeder Farbe steht für einen ''committer'', aber bei dem projekt gab es nur 2 Entwickler.}
[figure]>

=== Commits Machen  ===

==== Vom ''working tree'' in den ''index'' ====

Der '''index''' (auch ''staging area'' oder ''cache'' genannt) bietet die Möglichkeit einen ''commit'' schrittweise zusammenzusetzen. 

<[block]{Quellcode dem ''index'' hinzufügen}
    @git add@
[block]>

<[block]{Sehen welche Dateien sich im ''index'' befinden}
    @git status@
[block]>


==== Vom ''index'' in das ''repository'' ====

<[block]{Alles im ''index'' als ''commit'' ins ''repository''}
    @git commit@
[block]>

<[block]{''commit message'' angeben}
    @git commit -m "MESSAGE"@
[block]>

<[block]{''index'' umgehen, und direkt vom ''working tree'' ins ''repository''}
    @git commit -a@
[block]>

<[block]{''working tree'' in einen früheren Zustand zurückversetzen}
    @git checkout@
[block]>

==== Transport Kommandos ====

<[figure][ht]
	<<<figs/transport-commands.pdf, scale=0.6>>>
	\caption{Zusammenhang von @git-add@, @git-commit@ und @git checkout@}
[figure]>

=== Commits Benennen ===

==== ''commits'' sind das Geheimniss ====


<[block]{aktueller ''commit''}
@HEAD@
[block]>

* Wie ihr vielleicht schon erahnen, könnt sind ''commits'' das Geheimniss um Git wirklich zu verstehen.
* Viele Git Kommandos akzeptieren einen ''commit'', und es gibt ein paar Alternativen (zu der lästigen 40-Zeichen-Sequenz) um diese zu benennen
* Meistens reicht für die Angabe von einem ''commit'' die ersten 4-7 Zeichen des ''object name'', auch bekannt als '''partial SHA'''
* @HEAD@ ist eine implizite Referenz zu dem aktuellsten ''commit''
* Relative Angaben werden mit \^{} und $\sim$ gemacht
* z.B. {\tt HEAD\^{}\^{}\^{}} und {\tt HEAD$\sim$3} sind equivalent und beschreiben beide den dritten ''commit'' vor @HEAD@

[frame]>

=== Inhalt von .git ===

\begin{frame}[fragile]
\frametitle{Inhalt von .git}

Git speichert alles in dem Verzeichniss {\tt.git/} auch bekannt als \textbf{git
directory}, hier sehen wir einen Ausschnitt.

\begin{verbatim}
    % tree -L 1  .git/
    .
    |-- HEAD            # der gegenwärtige HEAD
    |-- config          # Konfiguration (user, email)
    |-- index           # der index
    |-- objects         # die eigentlichen Objekte

\end{verbatim}

\end{frame}

=== Commit Geschichte ===

==== Die ''commit'' Geschichte einsehen ====

<[block]{Alle ''commits'' anzeigen}
@git log@
[block]>

<[block]{Optionen}
\begin{tabular}{ l l }
{\tt git log -N}                            & die letzten @N@ anzeigen\\
{\tt git log COMMIT}                        & bis zu @COMMIT@ anzeigen \\
{\tt git log -{-}since="23 hours"}            & alle seit ... \\
{\tt git log -{-}before="42 days"}            & alle vor ... \\
{\tt git log -{-}pretty=oneline}              & ein ''commit'' pro Zeile \\
{\tt git log A..B}                          & alle zwischen {\tt A} und {\tt B}
\end{tabular}
[block]>

=== Unterschiede ===

==== Unterschiede ====

<[block]{Unterschiede zwischen ''working tree'' ohne ''index'' und @HEAD@}
@git diff@
[block]>

<[block]{Unterschiede zwischen ''index'' und ''repository''}
@git diff --cached@
[block]>

<[block]{Unterschiede zwischen ''working tree'' mit ''index'' und @HEAD@}
@git diff HEAD@
[block]>

<[block]{Unterschiede zwischen zwei ''commits''}
@git diff A B@
[block]>

== Fortgeschrittener Arbeitsablauf ==

==== Fahrplan ====

\tableofcontents[currentsection]


=== Branches ===

==== Branches ====

* Bisher: lineare ''commit'' Geschichte
* Nicht-Linerität ist wichtig
* ''Branches'' sind die Lösung
* Sind keine schwarze Magie
* Sondern einfach nur ''commits''

==== Branch Diagram ==== 

* '''Branch''': eine Referenz zu einem  ''commit''
* Ein ''commit'' hat Vorfahren
* Der gemeinsame Vorfahre heisst '''base commit'''

<[figure][ht]
    <<<figs/branch-basic.pdf, scale=0.6>>>
[figure]>

* '''Master''': meist der haupt ''branch'' in einem ''repository''

==== Branch Kommandos ====


<[block]{Anzeigen aller ''branches''}
@git branch@
[block]>

<[block]{Erstellen von einem ''branch''}
@git branch NAME@
[block]>

<[block]{In einen ''branch'' wechseln}
@git checkout NAME@
[block]>

<[block]{'branch' löschen}
@git branch -d NAME@
[block]>

<[block]{'branch' umbenennen}
@git branch -m OLD NEW@
[block]>

=== Merging ===

==== Verschiedene Merge Strategien ====

Das Zusammenführen von Veränderungen aus zwei (oder mehr) ''branches'' kann auf vielerlei Arten passieren:

* '''Fast Forward''': den @HEAD@ vorspulen 
* '''Straight Merging''':  aus @HEAD@s von ''branches'' einen neuen ''commit'' machen
* '''Rebaseing''': den ''base commit'' ändern

==== ''fast forward'' ====

<[block]{Wenn der @HEAD@ der ''base commit'' ist}
@git merge@
[block]>

<[block]{vorher}
<[figure][ht]
    \includegraphics[scale=0.35]{figs/fast-forward-before.pdf}
[figure]>
[block]>

\pause

<[block]{nachher}
<[figure][ht]
    \includegraphics[scale=0.35]{figs/fast-forward-after.pdf}
[figure]>
[block]>



==== ''straight merge '' ====

<[block]{Wenn der @HEAD@ nicht der ''base commit'' ist}
@git merge@
[block]>

<[block]{vorher}
<[figure][ht]
    \includegraphics[scale=0.35]{figs/merge-before.pdf}
[figure]>
[block]>

\pause

<[block]{nachher}
<[figure][ht]
    \includegraphics[scale=0.35]{figs/merge-after.pdf}
[figure]>
[block]>

==== ''rebaseing'' ====

<[block]{Ändern vom ''base commit''}
@git rebase@
[block]>

<[block]{vorher}
<[figure][ht]
    \includegraphics[scale=0.35]{figs/merge-before.pdf}
[figure]>
[block]>

\pause

<[block]{nachher}
<[figure][ht]
    \includegraphics[scale=0.35]{figs/rebase-after.pdf}
[figure]>
[block]>


=== Tags ===

==== Tags ====

Da die ''SHA-1 IDs'' unhandlich und semantikarm sind bietet Git eine
Möglichkeit um ''commits'' mit Namen, so genanten ''tags'', zu versehen. z.B.
um eine Version zu kennzeichnen.

<[block]{Anzeigen aller tags}
@git tag@
[block]>

<[block]{Den @HEAD@ mit einem ''tag'' versehn}
@git tag NAME@
[block]>

<[block]{''tag'' löschen}
@git tag -d NAME@
[block]>

=== Zurücksetzen ===

==== Veränderungen Rückgängig machen die noch nicht im ''repository'' sind ====

<[block]{Veränderung aus dem ''index'' herausnehmen (''unstage'')}
@git reset HEAD@
[block]>

<[block]{Einzelne Datei zurücksetzen}
@git checkout FILE@
[block]>

<[block]{Gesamten ''working tree'' zurücksetzen}
@git reset -{-}hard HEAD@
[block]>

\textcolor{red}{\textbf{VORSICHT!} Veränderungen am ''working tree'' die zurückgesetzt werden sind unwiderruflich gelöscht}

==== Veränderungen Rückgängig machen die bereites im ''repository'' sind ====

* Um ''commits'' rückgängig zu machen verwenden wir wieder @git reset COMMIT@, z.B. @git reset HEAD\^{}@
** Ohne option kommen die Veränderungen in den ''working tree''
** Die option @-{-}soft@ führt dazu das die Veränderungen in den ''index'' kommen
** Die option @-{-}hard@ führt dazu das die Veränderungen gelöscht werden (\textbf{VORSICHT!})
* Es gibt jedoch eine viel bessere Alternative als ''commits'' zu löschen, und zwar können wir mit @git revert@ einen neuen ''commit'' erstellen der die Veränderungen eines alten ''commits'' wieder rückgängig macht, somit bleiben alle Veränderungen erhalten.
* Ausserdem gibt es mit @git rebase@ folgende Optionen: Reihenfolge der ''commits'' ändern, ''commits'' trennen und zusammenfügen, sowie ''commits'' zu editieren

== Schluss ==

==== Nützliches ====

* Die Option @-{-}patch@ bzw. @-p@ für @git add@ erlaubt es interaktiv einzelne Blöcke zu wählen
* Um dem letzten ''commit'' noch eine kleine Änderung hinzuzufügen: @git commit -reuse-message=HEAD -a --ammend@


==== Was ich euch nicht erzählt habe ====

* Der Umgang mit entfernten ''repositories'' via @git push@, @git pull@ und @git fetch@
* Das Lösen von Konflikten die bei @merge@ und @rebase@ auftreten können
* Was wir mit @git rebase@ noch so alles machen können, z.B. ''commit'' Reinfolge ändern
* Dateien ignorieren
* Git in eclipse mit egit oder gitclipse
* Patches formattieren und per Email versenden
* Was der @reflog@ ist, und warum er ALLES speichert
* Wie man @git stash@ verwendet
* Git aliase

==== Literatur Empfehlungen ====

* Pragmatic Version Control Using Git, by Travis Swicegood (200 pages, Dec 2008, ISBN: 9781934356159 )
* Sehr gute Einführung, exzellente Beispiele die auch online verfügbar sind

* \href{http://www.newartisans.com/2008/04/git-from-the-bottom-up.html}{git-from-the-bottom-up}
* Sehr gute Beschreibung der Details, relativ kurz

* \href{http://book.git-scm.com/}{git community book}
* Hervoragende beschreibung von ''objects'' und implementations Details, mit Videos

==== Dank ====

Dank gilt den Entwicklern von:
* wiki2beamer
* \LaTeX beamer
* impressive
* pdflatex
* gnu make
* vim

Dank gilt Folgenden Personen fürs Korrekturlesen
* Dan Levin
* Sebastian Pipping




